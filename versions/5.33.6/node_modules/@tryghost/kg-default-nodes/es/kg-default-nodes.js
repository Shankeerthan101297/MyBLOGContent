import { DecoratorNode, createCommand } from 'lexical';

class KoenigDecoratorNode extends DecoratorNode {}
function $isKoenigCard(node) {
  return node instanceof KoenigDecoratorNode;
}

class ImageParser {
  constructor($createNode) {
    this.$createNode = $createNode;
  }
  get DOMConversionMap() {
    const self = this;
    return {
      img: () => ({
        conversion(domNode) {
          if (domNode.tagName === 'IMG') {
            const {
              alt: altText,
              src,
              title,
              width,
              height
            } = domNode;
            const node = self.$createNode({
              altText,
              src,
              title,
              width,
              height
            });
            return {
              node
            };
          }
          return null;
        },
        priority: 1
      })
      // TODO: add <figure> and other handling from kg-parser-plugins
    };
  }
}

const getAvailableImageWidths = function (image, imageSizes) {
  // get a sorted list of the available responsive widths
  const imageWidths = Object.values(imageSizes).map(_ref => {
    let {
      width
    } = _ref;
    return width;
  }).sort((a, b) => a - b);

  // select responsive widths that are usable based on the image width
  const availableImageWidths = imageWidths.filter(width => width <= image.width);

  // add the original image size to the responsive list if it's not captured by largest responsive size
  // - we can't know the width/height of the original `src` image because we don't know if it was resized
  //   or not. Adding the original image to the responsive list ensures we're not showing smaller sized
  //   images than we need to be
  if (image.width > availableImageWidths[availableImageWidths.length - 1] && image.width < imageWidths[imageWidths.length - 1]) {
    availableImageWidths.push(image.width);
  }
  return availableImageWidths;
};

const isLocalContentImage = function (url) {
  let siteUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  const normalizedSiteUrl = siteUrl.replace(/\/$/, '');
  const imagePath = url.replace(normalizedSiteUrl, '');
  return /^(\/.*|__GHOST_URL__)\/?content\/images\//.test(imagePath);
};

const isUnsplashImage = function (url) {
  return /images\.unsplash\.com/.test(url);
};

// default content sizes: [600, 1000, 1600, 2400]

const getSrcsetAttribute = function (_ref) {
  let {
    src,
    width,
    options
  } = _ref;
  if (!options.imageOptimization || options.imageOptimization.srcsets === false || !width || !options.imageOptimization.contentImageSizes) {
    return;
  }
  if (isLocalContentImage(src, options.siteUrl) && options.canTransformImage && !options.canTransformImage(src)) {
    return;
  }
  const srcsetWidths = getAvailableImageWidths({
    width
  }, options.imageOptimization.contentImageSizes);

  // apply srcset if this is a relative image that matches Ghost's image url structure
  if (isLocalContentImage(src, options.siteUrl)) {
    const [, imagesPath, filename] = src.match(/(.*\/content\/images)\/(.*)/);
    const srcs = [];
    srcsetWidths.forEach(srcsetWidth => {
      if (srcsetWidth === width) {
        // use original image path if width matches exactly (avoids 302s from size->original)
        srcs.push(`${src} ${srcsetWidth}w`);
      } else if (srcsetWidth <= width) {
        // avoid creating srcset sizes larger than intrinsic image width
        srcs.push(`${imagesPath}/size/w${srcsetWidth}/${filename} ${srcsetWidth}w`);
      }
    });
    if (srcs.length) {
      return srcs.join(', ');
    }
  }

  // apply srcset if this is an Unsplash image
  if (isUnsplashImage(src)) {
    const unsplashUrl = new URL(src);
    const srcs = [];
    srcsetWidths.forEach(srcsetWidth => {
      unsplashUrl.searchParams.set('w', srcsetWidth);
      srcs.push(`${unsplashUrl.href} ${srcsetWidth}w`);
    });
    return srcs.join(', ');
  }
};
const setSrcsetAttribute = function (elem, image, options) {
  if (!elem || !['IMG', 'SOURCE'].includes(elem.tagName) || !elem.getAttribute('src') || !image) {
    return;
  }
  const {
    src,
    width
  } = image;
  const srcset = getSrcsetAttribute({
    src,
    width,
    options
  });
  if (srcset) {
    elem.setAttribute('srcset', srcset);
  }
};

const resizeImage = function (image) {
  let {
    width: desiredWidth,
    height: desiredHeight
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    width,
    height
  } = image;
  const ratio = width / height;
  if (desiredWidth) {
    const resizedHeight = Math.round(desiredWidth / ratio);
    return {
      width: desiredWidth,
      height: resizedHeight
    };
  }
  if (desiredHeight) {
    const resizedWidth = Math.round(desiredHeight * ratio);
    return {
      width: resizedWidth,
      height: desiredHeight
    };
  }
};

function renderImageNodeToDOM(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /* c8 ignore start */
  if (!options.createDocument) {
    let document = typeof window !== 'undefined' && window.document;
    if (!document) {
      throw new Error('renderImageNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
    }

    options.createDocument = function () {
      return document;
    };
  }
  /* c8 ignore stop */

  const document = options.createDocument();
  if (!node.getSrc() || node.getSrc().trim() === '') {
    return document.createTextNode('');
  }
  const figure = document.createElement('figure');
  let figureClasses = 'kg-card kg-image-card';
  if (node.getCardWidth() !== 'regular') {
    figureClasses += ` kg-width-${node.getCardWidth()}`;
  }
  figure.setAttribute('class', figureClasses);
  const img = document.createElement('img');
  img.setAttribute('src', node.getSrc());
  img.setAttribute('alt', node.getAltText());
  img.setAttribute('loading', 'lazy');
  if (node.getTitle()) {
    img.setAttribute('title', node.getTitle());
  }
  if (node.getImgWidth() && node.getImgHeight()) {
    img.setAttribute('width', node.getImgWidth());
    img.setAttribute('height', node.getImgHeight());
  }

  // images can be resized to max width, if that's the case output
  // the resized width/height attrs to ensure 3rd party gallery plugins
  // aren't affected by differing sizes
  const {
    canTransformImage
  } = options;
  const {
    defaultMaxWidth
  } = options.imageOptimization || {};
  if (defaultMaxWidth && node.getImgWidth() > defaultMaxWidth && isLocalContentImage(node.getSrc(), options.siteUrl) && canTransformImage && canTransformImage(node.getSrc())) {
    const imageDimensions = {
      width: node.getImgWidth(),
      height: node.getImgHeight()
    };
    const {
      width,
      height
    } = resizeImage(imageDimensions, {
      width: defaultMaxWidth
    });
    img.setAttribute('width', width);
    img.setAttribute('height', height);
  }
  if (options.target !== 'email') {
    const imgAttributes = {
      src: node.getSrc(),
      width: node.getImgWidth(),
      height: node.getImgHeight()
    };
    setSrcsetAttribute(img, imgAttributes, options);
    if (img.getAttribute('srcset') && node.getImgWidth() && node.getImgWidth() >= 720) {
      // standard size
      if (!node.getCardWidth() || node.getCardWidth() === 'regular') {
        img.setAttribute('sizes', '(min-width: 720px) 720px');
      }
      if (node.getCardWidth() === 'wide' && node.getImgWidth() >= 1200) {
        img.setAttribute('sizes', '(min-width: 1200px) 1200px');
      }
    }
  }

  // Outlook is unable to properly resize images without a width/height
  // so we add that at the expected size in emails (600px) and use a higher
  // resolution image to keep images looking good on retina screens
  if (options.target === 'email' && node.getImgWidth() && node.getImgHeight()) {
    let imageDimensions = {
      width: node.getImgWidth(),
      height: node.getImgHeight()
    };
    if (node.getImgWidth() >= 600) {
      imageDimensions = resizeImage(imageDimensions, {
        width: 600
      });
    }
    img.setAttribute('width', imageDimensions.width);
    img.setAttribute('height', imageDimensions.height);
    if (isLocalContentImage(node.getSrc(), options.siteUrl) && options.canTransformImage?.(node.getSrc())) {
      // find available image size next up from 2x600 so we can use it for the "retina" src
      const availableImageWidths = getAvailableImageWidths(node, options.imageOptimization.contentImageSizes);
      const srcWidth = availableImageWidths.find(width => width >= 1200);
      if (!srcWidth || srcWidth === node.getImgWidth()) ; else {
        const [, imagesPath, filename] = node.getSrc().match(/(.*\/content\/images)\/(.*)/);
        img.setAttribute('src', `${imagesPath}/size/w${srcWidth}/${filename}`);
      }
    }
  }
  figure.appendChild(img);
  if (node.getCaption()) {
    const caption = document.createElement('figcaption');
    caption.innerHTML = node.getCaption();
    figure.appendChild(caption);
  }
  return figure;
}

const INSERT_IMAGE_COMMAND = createCommand();
const UPLOAD_IMAGE_COMMAND = createCommand();
class ImageNode extends KoenigDecoratorNode {
  // payload properties
  __src;
  __caption;
  __title;
  __altText;
  __cardWidth;
  __width;
  __height;
  static getType() {
    return 'image';
  }
  static clone(node) {
    return new ImageNode(node.getDataset(), node.__key);
  }

  // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
  static get urlTransformMap() {
    return {
      src: 'url',
      caption: 'html'
    };
  }
  getDataset() {
    return {
      src: this.__src,
      caption: this.__caption,
      title: this.__title,
      altText: this.__altText,
      width: this.__width,
      height: this.__height,
      cardWidth: this.__cardWidth
    };
  }

  // from https://github.com/TryGhost/Ghost/blob/main/ghost/admin/app/components/gh-image-uploader.js#L18
  static extensionTypes = ['gif', 'jpg', 'jpeg', 'png', 'svg', 'svgz', 'webp'];
  static mimeTypes = ['image/gif', 'image/jpg', 'image/jpeg', 'image/png', 'image/svg+xml', 'image/webp'];
  constructor() {
    let {
      src,
      caption,
      title,
      altText,
      cardWidth,
      width,
      height
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    super(key);
    this.__src = src || '';
    this.__title = title || '';
    this.__caption = caption || '';
    this.__altText = altText || '';
    this.__width = width || null;
    this.__height = height || null;
    this.__cardWidth = cardWidth || 'regular';
  }
  static importJSON(serializedNode) {
    const {
      src,
      caption,
      title,
      altText,
      width,
      height,
      cardWidth
    } = serializedNode;
    const node = $createImageNode({
      src,
      caption,
      title,
      altText,
      width,
      height,
      cardWidth
    });
    return node;
  }
  exportJSON() {
    // checks if src is a data string
    const src = this.getSrc();
    const isBlob = src.startsWith('data:');
    const dataset = {
      type: 'image',
      src: isBlob ? '<base64String>' : this.getSrc(),
      width: this.getImgWidth(),
      height: this.getImgHeight(),
      title: this.getTitle(),
      altText: this.getAltText(),
      caption: this.getCaption(),
      cardWidth: this.getCardWidth()
    };
    return dataset;
  }
  static importDOM() {
    const parser = new ImageParser($createImageNode);
    return parser.DOMConversionMap;
  }
  exportDOM() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const element = renderImageNodeToDOM(this, options);
    return {
      element
    };
  }

  /* c8 ignore start */
  createDOM() {
    const element = document.createElement('div');
    return element;
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return false;
  }
  /* c8 ignore stop */

  getSrc() {
    return this.__src;
  }
  setSrc(src) {
    const writable = this.getWritable();
    return writable.__src = src;
  }
  getTitle() {
    return this.__title;
  }
  setTitle(title) {
    const writable = this.getWritable();
    return writable.__title = title;
  }
  setCardWidth(cardWidth) {
    const writable = this.getWritable();
    return writable.__cardWidth = cardWidth;
  }
  getCardWidth() {
    return this.__cardWidth;
  }
  getImgWidth() {
    return this.__width;
  }
  setImgWidth(width) {
    const writable = this.getWritable();
    return writable.__width = width;
  }
  getImgHeight() {
    return this.__height;
  }
  setImgHeight(height) {
    const writable = this.getWritable();
    return writable.__height = height;
  }
  getCaption() {
    return this.__caption;
  }
  setCaption(caption) {
    const writable = this.getWritable();
    return writable.__caption = caption;
  }
  getAltText() {
    return this.__altText;
  }
  setAltText(altText) {
    const writable = this.getWritable();
    return writable.__altText = altText;
  }

  // should be overridden
  /* c8 ignore next 3 */
  decorate() {
    return '';
  }
}
const $createImageNode = dataset => {
  return new ImageNode(dataset);
};
function $isImageNode(node) {
  return node instanceof ImageNode;
}

// export convenience objects for use elsewhere
const DEFAULT_NODES = [ImageNode];

export { $createImageNode, $isImageNode, $isKoenigCard, DEFAULT_NODES, INSERT_IMAGE_COMMAND, ImageNode, ImageParser, KoenigDecoratorNode, UPLOAD_IMAGE_COMMAND };
//# sourceMappingURL=kg-default-nodes.js.map
